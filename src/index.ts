import {
  Agent,
  ApiQueryResponse,
  Certificate,
  compare,
  concat,
  CreateCertificateOptions,
  HttpAgent,
  Identity,
  PublicKey,
  QueryFields,
  QueryResponseStatus,
  ReadStateOptions,
  ReadStateResponse,
  requestIdOf,
  RequestStatusResponseStatus,
  Signature,
  SignIdentity,
  SubmitRequestType,
  SubmitResponse,
} from "@dfinity/agent";
import { JsonObject, lebEncode } from "@dfinity/candid";
import {
  CanisterCallJsonRequest,
  CanisterCallJsonResponse,
  PermissionJsonRequest,
  PermissionJsonResponse,
  Transport,
} from "./transport/index.js";
import { Buffer } from "buffer";
import { Principal } from "@dfinity/principal";
import {
  Delegation,
  DelegationChain,
  DelegationIdentity,
  isDelegationValid,
} from "@dfinity/identity";
import { isIdentitySignatureValid } from "./signature/index.js";

export const ICP_NETWORK_CHAIN_ID = "icp:737ba355e855bd4b61279056603e0550";
export const ICP_NETWORK_NAME = "Internet Computer";

interface WalletAgentOptions {
  transport: Transport;
  crypto?: Pick<Crypto, "randomUUID" | "getRandomValues">;
  /**
   * Optional, used to fetch root key and make calls with delegation chain,
   * HttpAgent with default options will be used when not set
   */
  agent?: HttpAgent;
  /** Optional polyfill for BLS verify used in query requests that are upgraded to calls */
  blsVerify?: CreateCertificateOptions["blsVerify"];
  /**
   * Optional, canister_call RPC calls can also be made with a signed challenge to skip the origin check,
   * also when "delegation" scope and public key are set in the permission request a delegation chain
   * is returned for the public key of this identity
   */
  identity?: Pick<SignIdentity, "getPublicKey" | "sign">;
}

export interface PermissionRequestParams {
  version: 1;
  appMetaData: {
    name: string;
    icon?: string;
  };
  /** Optional, will be generated by WalletAgent when not defined */
  networks?: Array<{
    chainId: string;
    name?: string;
  }>;
  scopes: Array<"canister_call" | "delegation">;
  /** Optional, will be generated by WalletAgent when not defined */
  challenge?: ArrayBuffer;
  targets?: Principal[];
}

export interface PermissionResponseResult {
  version: 1;
  appMetaData: {
    name: string;
    icon?: string;
  };
  scopes: Array<"canister_call" | "delegation">;
  identities: Array<{
    publicKey: PublicKey;
    signature: Signature;
    ledger?: {
      subaccounts?: Array<{
        bytes: ArrayBuffer;
        name?: string;
      }>;
    };
    /**
     * Will be returned if above challenge signature was signed with a delegated public key or
     * when "delegation" scope and public key are set in the permission request
     */
    delegationChain?: DelegationChain;
  }>;
}

export class WalletAgent implements Agent {
  /** Required, sender must be set to make calls */
  public sender?: Principal;
  /** Optional, if delegation is valid for the call, the call will be made with delegation instead of JSON-RPC */
  public delegationChain?: DelegationChain;

  private agent: HttpAgent;
  private readStateResponses: Record<string, ReadStateResponse> = {};
  private delegatedRequests: string[] = [];

  constructor(private options: WalletAgentOptions) {
    this.agent = options.agent ?? new HttpAgent();
  }

  public get rootKey() {
    return this.agent.rootKey;
  }

  public async permission(
    params: PermissionRequestParams,
  ): Promise<PermissionResponseResult> {
    return new Promise<PermissionResponseResult>(async (resolve, reject) => {
      const id = this.getCrypto().randomUUID();
      const challenge = params.challenge
        ? new Uint8Array(params.challenge)
        : this.getCrypto().getRandomValues(new Uint8Array(32));
      const listener =
        await this.options.transport.registerListener<PermissionJsonResponse>(
          async (response) => {
            if (response.id !== id) {
              return;
            }
            if ("error" in response) {
              reject(response.error);
              listener();
              return;
            }
            if ("result" in response) {
              const result: PermissionResponseResult = {
                version: response.result.version,
                appMetaData: {
                  name: response.result.appMetaData.name,
                  icon: response.result.appMetaData.icon,
                },
                scopes: response.result.scopes,
                identities: response.result.identities.map((identity) => {
                  const derEncodedPublicKey = Buffer.from(
                    identity.publicKey,
                    "base64",
                  );
                  return {
                    publicKey: { toDer: () => derEncodedPublicKey },
                    signature: Buffer.from(identity.signature, "base64")
                      .buffer as Signature,
                    delegationChain: identity.delegationChain
                      ? DelegationChain.fromDelegations(
                          identity.delegationChain.map((item) => ({
                            delegation: new Delegation(
                              Buffer.from(item.delegation.publicKey, "base64"),
                              BigInt(item.delegation.expiration),
                              item.delegation.targets?.map((target) =>
                                Principal.fromText(target),
                              ),
                            ),
                            signature: Buffer.from(item.signature, "base64")
                              .buffer as Signature,
                          })),
                          derEncodedPublicKey,
                        )
                      : undefined,
                    ledger: identity.ledger
                      ? {
                          subaccounts: identity.ledger.subaccounts?.map(
                            (subaccount) => ({
                              bytes: Buffer.from(subaccount.bytes, "base64"),
                              name: subaccount.name,
                            }),
                          ),
                        }
                      : undefined,
                  };
                }),
              };
              const walletChallenge = new Uint8Array(
                concat(
                  new TextEncoder().encode("\x0Aic-wallet-challenge").buffer,
                  challenge,
                ),
              );
              // Signature validation is done one by one, so we don't have to wait for remaining identity validations
              // after an identity is found to be invalid. Since the validation is not native but runs in the JS thread,
              // running them in parallel does not make a difference in performance since JS is single threaded.
              for (const identity of result.identities) {
                if (
                  !(await isIdentitySignatureValid({
                    publicKey: identity.publicKey.toDer(),
                    signature: identity.signature,
                    challenge: walletChallenge,
                    rootKey: this.rootKey,
                    delegationChain: identity.delegationChain?.toJSON(),
                  }))
                ) {
                  reject("Identity signature is invalid");
                  listener();
                  return;
                }
              }
              resolve(result);
              listener();
              return;
            }
          },
        );
      await this.options.transport.send<PermissionJsonRequest>({
        id,
        jsonrpc: "2.0",
        method: "permission",
        params: {
          version: params.version,
          appMetaData: params.appMetaData,
          networks: params.networks ?? [
            {
              chainId: ICP_NETWORK_CHAIN_ID,
              name: ICP_NETWORK_NAME,
            },
          ],
          scopes: params.scopes,
          challenge: Buffer.from(challenge).toString("base64"),
          publicKey: this.options.identity
            ? Buffer.from(
                this.options.identity.getPublicKey().toDer(),
              ).toString("base64")
            : undefined,
          targets: params.targets
            ? params.targets.map((target) => target.toText())
            : undefined,
        },
      });
    });
  }

  public async call(
    canisterId: Principal | string,
    options: {
      methodName: string;
      arg: ArrayBuffer;
      effectiveCanisterId?: Principal | string;
    },
  ): Promise<SubmitResponse> {
    if (
      this.delegationChain &&
      this.options.identity &&
      isDelegationValid(this.delegationChain, { scope: canisterId })
    ) {
      const submitResponse = await this.agent.call(
        canisterId,
        options,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
      this.delegatedRequests.push(
        Buffer.from(submitResponse.requestId).toString("base64"),
      );
      return submitResponse;
    }
    if (!this.sender) {
      throw Error(
        "Sender is not defined, make sure to set sender after permission request",
      );
    }
    return new Promise<SubmitResponse>(async (resolve, reject) => {
      const id = this.getCrypto().randomUUID();
      const listener =
        await this.options.transport.registerListener<CanisterCallJsonResponse>(
          async (response) => {
            if (response.id !== id) {
              return;
            }
            if ("error" in response) {
              reject(response.error);
              listener();
              return;
            }
            if ("result" in response) {
              if (
                response.result.contentMap.request_type !==
                  SubmitRequestType.Call ||
                response.result.contentMap.canister_id !==
                  Principal.from(canisterId).toText() ||
                response.result.contentMap.method_name !== options.methodName ||
                compare(
                  Buffer.from(response.result.contentMap.arg, "base64").buffer,
                  options.arg,
                ) !== 0 ||
                response.result.contentMap.sender !== this.sender!.toText()
              ) {
                reject("Received invalid content map from wallet");
                listener();
                return;
              }
              const requestId = requestIdOf({
                request_type: SubmitRequestType.Call,
                canister_id: Principal.from(canisterId),
                method_name: options.methodName,
                arg: options.arg,
                sender: this.sender,
                ingress_expiry: {
                  toHash: () =>
                    lebEncode(
                      BigInt(response.result.contentMap.ingress_expiry),
                    ),
                },
                ...(response.result.contentMap.nonce
                  ? {
                      nonce: Buffer.from(
                        response.result.contentMap.nonce,
                        "base64",
                      ).buffer,
                    }
                  : {}),
              });
              this.readStateResponses[
                Buffer.from(requestId).toString("base64")
              ] = {
                certificate: Buffer.from(response.result.certificate, "base64")
                  .buffer,
              };
              resolve({
                requestId,
                response: {
                  ok: true,
                  status: 200,
                  statusText: "Call has been sent over JSON-RPC",
                  body: null,
                  headers: [],
                },
              });
              listener();
            }
          },
        );
      const canisterCallSignature = requestIdOf({
        request_type: SubmitRequestType.Call,
        canister_id: Principal.from(canisterId),
        method_name: options.methodName,
        arg: options.arg,
        sender: this.sender,
        // Expiry is missing here since it's defined by the wallet making the actual call
      });
      await this.options.transport.send<CanisterCallJsonRequest>({
        id,
        jsonrpc: "2.0",
        method: "canister_call",
        params: {
          version: 1,
          network: {
            chainId: ICP_NETWORK_CHAIN_ID,
            name: ICP_NETWORK_NAME,
          },
          canisterId: Principal.from(canisterId).toText(),
          sender: this.sender!.toText(),
          method: options.methodName,
          arg: Buffer.from(options.arg).toString("base64"),
          publicKey: this.options.identity
            ? Buffer.from(
                this.options.identity.getPublicKey().toDer(),
              ).toString("base64")
            : undefined,
          signature: this.options.identity
            ? Buffer.from(
                await this.options.identity.sign(canisterCallSignature),
              ).toString("base64")
            : undefined,
        },
      });
    });
  }

  public async fetchRootKey(): Promise<ArrayBuffer> {
    return this.agent.fetchRootKey();
  }

  public async getPrincipal(): Promise<Principal> {
    return this.sender ?? Principal.anonymous();
  }

  public async query(
    canisterId: Principal | string,
    options: QueryFields,
  ): Promise<ApiQueryResponse> {
    if (
      this.delegationChain &&
      this.options.identity &&
      isDelegationValid(this.delegationChain, { scope: canisterId })
    ) {
      return this.agent.query(
        canisterId,
        options,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
    }
    // Upgrade query request to a call
    const submitResponse = await this.call(canisterId, options);
    const id = Buffer.from(submitResponse.requestId).toString("base64");
    const state = this.readStateResponses[id];
    delete this.readStateResponses[id];
    if (this.rootKey == null) {
      throw new Error("Agent root key not initialized");
    }
    const cert = await Certificate.create({
      certificate: state.certificate,
      rootKey: this.rootKey,
      canisterId: Principal.from(canisterId),
      blsVerify: this.options.blsVerify,
    });
    const path = [
      new TextEncoder().encode("request_status"),
      submitResponse.requestId,
    ];
    const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
    const status = maybeBuf && new TextDecoder().decode(maybeBuf);
    if (status === RequestStatusResponseStatus.Replied) {
      return {
        status: QueryResponseStatus.Replied,
        reply: {
          arg: cert.lookup([...path, "reply"])!,
        },
        httpDetails: {
          ok: true,
          status: 200,
          statusText: "Certificate with reply has been received over JSON-RPC",
          headers: [],
        },
      };
    }
    throw Error("Certificate is missing reply");
  }

  public async createReadStateRequest(
    options: ReadStateOptions,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ): Promise<any> {
    const id = this.requestIdFromReadStateOptions(options);
    if (
      id &&
      this.delegatedRequests.includes(id) &&
      this.delegationChain &&
      this.options.identity
    ) {
      return this.agent.createReadStateRequest(
        options,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
      );
    }
  }

  public async readState(
    canisterId: Principal | string,
    options: ReadStateOptions,
    identity?: Identity | Promise<Identity>,
    // eslint-disable-next-line
    request?: any,
  ): Promise<ReadStateResponse> {
    const id = this.requestIdFromReadStateOptions(options);
    if (
      id &&
      this.delegatedRequests.includes(id) &&
      this.delegationChain &&
      this.options.identity
    ) {
      return this.agent.readState(
        canisterId,
        options,
        DelegationIdentity.fromDelegation(
          this.options.identity,
          this.delegationChain,
        ),
        request,
      );
    }
    if (id && id in this.readStateResponses) {
      const readStateResponse = this.readStateResponses[id];
      delete this.readStateResponses[id];
      return readStateResponse;
    }
    throw Error(
      "Invalid read state request, request wasn't made through the WalletAgent",
    );
  }

  public async status(): Promise<JsonObject> {
    return this.agent.status();
  }

  private requestIdFromReadStateOptions = (
    options: ReadStateOptions,
  ): string | undefined => {
    if (options.paths.length === 1 && options.paths[0].length == 2) {
      const path = new TextDecoder().decode(options.paths[0][0]);
      if (path === "request_status") {
        return Buffer.from(options.paths[0][1]).toString("base64");
      }
    }
  };

  private getCrypto(): Pick<Crypto, "randomUUID" | "getRandomValues"> {
    return this.options.crypto ?? window.crypto;
  }
}

export * from "./transport/index.js";
export * from "./signature/index.js";
